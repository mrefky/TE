package main
import(
"fmt"
"sync"
"github.com/Shopify/sarama"
cluster "github.com/bsm/sarama-cluster"
"log"
"time"
"database/sql"
            _ "github.com/go-sql-driver/mysql"
"encoding/json"
"strconv"
//"os"
)
type Order struct {
	ID       string          
	Side      string          
	Quantity  int32
	Price     float64
	Timestamp int64           
}

type Trade struct {
	Taker_Order_ID string 
	Maker_Order_ID string 
	Quantity     int32
	Price        float64 
	Timestamp    int64  
}

func main(){

 
	var wg sync.WaitGroup
	wg.Add(2)
	go func (){
		f()

	wg.Done()


	}()

	//wg1.Add(1)
	go func (){
		ftrade()

	wg.Done()


	}()

fmt.Println("Staring to Update Mysql")
db, err := sql.Open("mysql", "root:pass@tcp(192.168.1.52:3306)/test")
        if err != nil {
         panic(err.Error())
                }
                                    defer db.Close()
                                        fmt.Println("Connecting to MySQL Success!")
//done := make(chan string)
//go f()

	//fmt.Println(done)

//go f()

//go  ftrade()
//go ftrade()
for {}
}
func (order *Order) FromJSON(msg []byte) error {
	return json.Unmarshal(msg, order)
}

func (trd *Trade) FromJSON(msg []byte) error {
	return json.Unmarshal(msg, trd)
}

func f() {
//endless loop reading orders topis and writing orders to orders table	
	consumer := createConsumer()
	//if len(sql) != 0 {
	
	for msg1 := range consumer.Messages() {
	//	var myString string
	
//	fmt.Println(string(msg.Value))

consumer.MarkOffset(msg1, "")

var ord Order
//fmt.Println(msg)
ord.FromJSON(msg1.Value)
//fmt.Println(ord)
var s1,s string
s = "INSERT INTO orders set orderid='" + ord.ID + "',Quantity='" + fmt.Sprint(ord.Quantity) + "',Price='" +  fmt.Sprintf("%f",ord.Price) + "'"
s = s + ",ordtype='" + ord.Side + "',ID=" + "'EGMFC001MM19',timestamp='" + strconv.FormatInt(ord.Timestamp, 10) + "'"
s1= "INSERT INTO matches set orderid='" + ord.ID + "',Quantity=0"
//fmt.Println(s)
//call the inset into orders function
//s=s+";"+s1+";"
//done := make(chan string)
kupdate(s)
//fmt.Println(<-done)
 kupdate(s1)
//fmt.Println(<-done)
//need to wait tilll the above finishe
//kupdate(string(msg.Value))
//time.Sleep(time.Second * 1)
//var x string
//x=s + s1

	}
}


func ftrade() {
	var trdID int
	trdID=0
	consumer2 := createConsumer2()
	//if len(sql) != 0 {
	
	for msg := range consumer2.Messages() {
	//	var myString string
	
//	fmt.Println(string(msg.Value))

consumer2.MarkOffset(msg, "")
var trd Trade
//fmt.Println(msg)
trd.FromJSON(msg.Value)
//fmt.Println(trd)
//return
var s,s1 string
var mqty string = fmt.Sprint(trd.Quantity)
s = "update matches set Quantity=Quantity+" + mqty
//s = s + ",Matched_Quantity= Matched_Quantity+" + mqty
s = s + " where orderid=" + trd.Maker_Order_ID
s = s + " or orderid=" + trd.Taker_Order_ID 
s1="insert into trades set MakerID='"+trd.Maker_Order_ID+"'"
s1=s1+",TakerID='"+trd.Taker_Order_ID+"'"
s1=s1+",Price='"+fmt.Sprintf("%f",trd.Price)+ "'"
s1=s1+",Quantity='"+fmt.Sprint(trd.Quantity)+"'"
s1=s1+",timestamp='"+ strconv.FormatInt(trd.Timestamp,10)+"'"
s1=s1+",tradeid='"+fmt.Sprint(trdID) +"';"
//fmt.Println(s1)
//fmt.Fprintf(file, "%v\n", )
trdID=trdID+1
//s1 = "update order set qunatity="
//fmt.Println(s1)
//fmt.Println(s1)
//s=s1+";"+s+";"
//done1 := make(chan string)
kupdate(s1)
//done2 := make(chan string)

kupdate(s)
//fmt.Println(<-done2)
//kupdate(string(msg.Value))
//time.Sleep(time.Second * 1)
	}
}


                     
func createConsumer() *cluster.Consumer {
	// define the configuration for our cluster
	config := cluster.NewConfig()
	config.Consumer.Return.Errors = true
	config.Group.Return.Notifications = false
	config.Consumer.Offsets.Initial = sarama.OffsetOldest // earliest uncommited offset
	config.Consumer.Offsets.CommitInterval = time.Second
	
	orderTopic := []string{"orders"}

	// log.Println("Listening for SQL on topic -> ", orderTopic)
	// create the consumer
	consumer, err := cluster.NewConsumer(
			[]string{"192.168.1.51:29092"},
			"SQLuiiuu",
			orderTopic,
			config,
	)

	if err != nil {
			log.Fatal("Unable to connect to kafka cluster")
	}

	go handleErrors(consumer)
	go handleNotifications(consumer)
	return consumer
}

func handleErrors(consumer *cluster.Consumer) {
	for err := range consumer.Errors() {
			log.Printf("Error: %s\n", err.Error())
	}
}

func handleNotifications(consumer *cluster.Consumer) {
	for ntf := range consumer.Notifications() {
			log.Printf("Rebalanced %+v\n", ntf)
	}
}
func kupdate(sql1 string){
	
	fmt.Println(sql1)
	db, err := sql.Open("mysql", "root@tcp(192.168.1.52:3306)/test")

	if err != nil {
					panic(err.Error())
			}
			defer db.Close()
			//var s string
			//var newqty int64=ord.Quantity-qty
			//s="update orders set Quantity=Quantity-"+strconv.FormatInt(mqty,10) +", Matched_Quantity= Matched_Quantity+'"+strconv.FormatInt(mqty,10)+"' where orderid="+Id
			//fmt.Println(">>>>>>>>>>>>>>",s)
	
			insert, err := db.Query(sql1)
			if err !=nil {
							panic(err.Error())
					}
					defer insert.Close()
			//      fmt.Println(Id," Order updaeted")
	//done <- sql1
			}
			//() 
			//<-done
			//}
			func createConsumer2() *cluster.Consumer {
				// define the configuration for our cluster
				config := cluster.NewConfig()
				config.Consumer.Return.Errors = true
				config.Group.Return.Notifications = false
				config.Consumer.Offsets.Initial = sarama.OffsetOldest // earliest uncommited offset
				config.Consumer.Offsets.CommitInterval = time.Second
				
				orderTopic := []string{"trades"}
			
				// log.Println("Listening for SQL on topic -> ", orderTopic)
				// create the consumer
				consumer, err := cluster.NewConsumer(
						[]string{"192.168.1.51:29092"},
						"SQLoouuo",
						orderTopic,
						config,
				)
			
				if err != nil {
						log.Fatal("Unable to connect to kafka cluster")
				}
			
				go handleErrors2(consumer)
				go handleNotifications2(consumer)
				return consumer
			}
			
			func handleErrors2(consumer2 *cluster.Consumer) {
				for err := range consumer2.Errors() {
						log.Printf("Error: %s\n", err.Error())
				}
			}
			
			func handleNotifications2(consumer2 *cluster.Consumer) {
				for ntf := range consumer2.Notifications() {
						log.Printf("Rebalanced %+v\n", ntf)
				}
			}
			
